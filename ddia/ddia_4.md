# 数据编码与演化

向后兼容： 新代码兼容旧数据

向前兼容： 旧代码兼容新数据

### 数据编码格式

* 内存数据结构， 与文件或网络发送数据的区别
* json、xml、二进制编码
  * 编码长度（占用空间大小）： 二进制编码 > json > xml

### 二进制编码

* thrift与protobuf
* freeschema: protobuf和thrift解析原始数据时需要知道编码模式, json和xml则不需要，这种编码被称作freeschema
* 因为二进制编码不需要存储数据的属性（字段）名称，所以可以节省更多的空间
* 模式演化与兼容： 只能减少optional（可选参数）字段，增加字段时的字段编号必须递增。
### Avro

* 编码中不存储字段的属性信息，完全依靠** reader和writer的解析代码 **来解析字符串的类型（string或int或double）
* 模式演化与兼容：只能添加或减少具有默认值的字段，因为没有标记字段编号，所以解析时无法跳过没有数据的字段。

优点： 由于只需要依赖代码实现而不必更高编码模式配置文件(比如.proto文件和.thrift文件)， 因此适合数据导出数据这样的动态生成的模式, 如数据库导出数据

### REST与RPC

* 微服务体系结构： 服务器本身是另一项服务的客户端， 将大型应用程序分解成较小的服务
* REST, 一种设计理念： 基于http， 使用简单的数据格式（如json）传输数据，使用HTTP功能进行缓存控制、身份验证
* RPC: 使向远程网络服务发出请求看起来像调用本地函数一样
* RPC 缺点：
  * 不可预测
  * 超时
  * 重试失败的请求导致会导致已经被完成的操作重复执行，参见幂等性
  * 执行时间相比于本地函数不可预测
  * 传递较大的参数时效率更低（无法传指针或者是传引用）
  * 客户端和服务端的编程语言不同，存在语言特性造成的隐患

### 基于消息传递的数据流 （消息队列）

* 优点:
  * 如果接收方不可过载， 可以充当缓冲区
  * 自动将消息重新发送到崩溃的进程，防止消息丢失
  * 将发送方与接收方解藕（发送方不需要知道接收方的ip和端口）
  * 可以将一条消息发送给多个接收方
