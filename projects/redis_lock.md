# redis分布式锁服务

> 本文包括两个部分，redlock算法，与Martin Kleppmann对redlock的批判

### redis实现单实例锁

```
SET resource_name my_random_value NX PX 30000
```

* 客户端生成一个随机数，将其存入redis锁的value中，解锁操作前先检查该锁是否仍由自己持有，再决定是否将key删除。

### redlock算法

> 搭建多个redis实例作为master，然后由redis客户端向所有的redis实例进行acquire lock操作，算法步骤如下

* 1.客户端获取当前时间
* 2.客户端按照顺序往每个master尝试获得锁，在此过程中，每次rpc请求有一个远小于锁租约时长的快速失败时间，当rpc过程超过着给时间时，则视作rpc失效。
* 3.客户端计算租约时长lease为lock存活时间（从步骤1的时间开始计数）减去之前所有获得锁操作消耗的时间，如果lease大于0，且从所有master中的大多数节点都成功获得了锁，则视作客户端持有该锁
* 4.客户端获得锁后开始执行任务，执行任务的时长小于步骤3中计算出来的lease。
* 5.如果客户端未能在大多数节点上获得锁，那么他开始回滚，归还已经获得锁的节点授权给他的锁

### redlock算法的缺陷

* 使用redislock的两种场景
  * 通过加锁避免重复计算引起的效率问题
  * 避免对相同资源的竞争修改引起程序错误或异常
* 对于第二种场景，redlock存在严重的正确性问题。
  * gc停顿或者系统进程暂停造成客户端在租约过期后没有及时退出。zookeeper给出的解决办法是每次租约附带递增编号的fencing令牌，状态机只接受fencing令牌递增的修改。但是redlock无法提供这样的递增令牌
  * 过度依赖时间。发生时钟漂移时会严重影响正确性。
    * 客户端a向master A、B、C、D、E发送锁请求，然后获得了A、B、C的响应，D、E无法接通。之后由于C发生了时钟漂移，锁提前到期，客户端b获得了C、D、E的锁，这时a和b都认为自己持有了锁。
  * 客户端C在持久化锁之前，服务崩溃并重启。导致锁丢失。该问题可通过fsync来解决
  * 客户端在发送锁请求之后发生了GC暂停，GC暂停后开始处理锁请求的回复，然后认为自己已经成功获得了多数节点的锁，但实际上此时master的锁租约已经过期。（redlock会在获取锁之后重新计算剩余的租约时间，因此该情况是否成立存疑）
    
